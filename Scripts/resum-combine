#-*- mode: python-*- 
import math as m
import glob
import argparse
import sys
import os
import subprocess
import yoda
import logging

value = 0
sumW_Sig = 1
sumW2_Sig = 2
err_Sig = 3
sumW_bSig = 4
sumW2_bSig = 5
err_bSig = 6
nEntries = 7


class Sigma(object):

    
    def __init__(self,values,AbsValues=False):
        self.AbsValues = AbsValues
        self.values = values


    @classmethod
    def from_file(cls, filename, toAbsValues=False):
        c = cls([])
        c.AbsValues = toAbsValues
        with open(filename,'r') as f:
            for line in f.readlines():
                if line.strip().startswith("#"): continue
                vals = line.split()
                if len(vals) != 8: continue
                c.values += [[float(val) for val in vals]]
        if toAbsValues:
            for i in range(len(c.values)):
                N = c.values[i][nEntries]
                c.values[i][sumW_Sig] *= N
                c.values[i][sumW_bSig] *= N
                c.values[i][sumW2_Sig] *= N
                c.values[i][sumW2_bSig] *= N
        return c

    @classmethod
    def from_yoda(cls, scatter):
        n = len(scatter.points)
        c = cls([[0]*8]*n)
        c.AbsValues = False
        sigma = scatter.points[-1].y
        sigma_err = (abs(scatter.points[-1].yErrs[0])
                     +abs(scatter.points[-1].yErrs[1]))/2.
        for i in range(n):
            p = scatter.points[i]
            c.values[i][value] = p.x
            c.values[i][sumW_Sig] = p.y
            c.values[i][err_Sig] = (abs(p.yErrs[0])+abs(p.yErrs[1]))/2.
            c.values[i][sumW_bSig] = sigma-p.y
            c.values[i][err_bSig] = m.sqrt(pow(sigma_err,2)+pow(c.values[i][err_Sig],2))
        return c
    
    def Sigma(self, v):
        for val in self.values:
            if abs(val[value]-v) < 1e-6:
                if self.AbsValues:
                    N = val[nEntries]
                    return (val[sumW_Sig]/N, val[err_Sig])
                else:
                    return (val[sumW_Sig], val[err_Sig])
        print("Value {} not found.".format(v))

    def barSigma(self, v):
        for val in self.values:
            if abs(val[value]-v) < 1e-6:
                if self.AbsValues:
                    N = val[nEntries]
                    return (val[sumW_bSig]/N, val[err_bSig])
                else:
                    return (val[sumW_bSig], val[err_bSig])
        print("Value {} not found.".format(v))

    def __add__(self,other):
        n = len(self.values)
        c = Sigma([[0]*8 for _ in range(n)])
        if self.AbsValues:
            assert other.AbsValues
            for i in range(n):
                vo = other.values[i]
                v = self.values[i]
                assert abs(v[value]-vo[value]) < 1e-6
                c.values[i][value] = v[value]
                c.values[i][sumW_Sig] = (v[sumW_Sig]+vo[sumW_Sig])
                c.values[i][sumW_bSig] = (v[sumW_bSig]+vo[sumW_bSig])
                c.values[i][sumW2_Sig] = (v[sumW2_Sig]+vo[sumW2_Sig])
                c.values[i][sumW2_bSig] = (v[sumW2_bSig]+vo[sumW2_bSig])
                c.values[i][nEntries] = (v[nEntries]+vo[nEntries])
                N = c.values[i][nEntries]
                c.values[i][err_Sig] = m.sqrt((c.values[i][sumW2_Sig]/N-pow(c.values[i][sumW_Sig]/N,2))/(N-1))
                c.values[i][err_bSig] = m.sqrt((c.values[i][sumW2_bSig]/N-pow(c.values[i][sumW_bSig]/N,2))/(N-1))
                c.AbsValues = True
        else:
            for i in range(n):
                vo = other.values[i]
                v = self.values[i]
                assert abs(v[value]-vo[value]) < 1e-6
                c.values[i][value] = v[value]
                c.values[i][sumW_Sig] = (v[sumW_Sig]+vo[sumW_Sig])
                c.values[i][err_Sig] = m.sqrt(pow(v[err_Sig],2)+pow(vo[err_Sig],2))
                c.values[i][sumW_bSig] = (v[sumW_bSig]+vo[sumW_bSig])
                c.values[i][err_bSig] = m.sqrt(pow(v[err_bSig],2)+pow(vo[err_bSig],2))
        return c

    def __getitem__(self,i):
        return self.values[i]
    
    def toYoda(self, path, title=None, mode="ln"):
        import yoda
        if title is None: title = path
        scatter1 = yoda.Scatter2D(path=path+"_Sigma",title=title+"_Sigma")
        scatter2 = yoda.Scatter2D(path=path+"_barSigma", title=title+"_Sigma")
        n = len(self.values)
        for i in range(n):
            v = self.values[i]
            if mode == "lin": x = v[value]
            elif mode == "log": x = m.log10(v[value])
            elif mode == "ln":  x = m.log(v[value])
            if self.AbsValues:
                N = v[nEntries]
                y = v[sumW_Sig]/N
            else:
                y = v[sumW_Sig]
            yerr = v[err_Sig]
            scatter1.addPoint(x,y,yerrs=(yerr,yerr))
            if self.AbsValues:
                y = v[sumW_bSig]/N
            else:
                y = v[sumW_bSig]
            yerr = v[err_bSig]
            scatter2.addPoint(x,y,yerrs=(yerr,yerr))
        return [scatter1,scatter2]


    def toFile(self,filename):
        with open(filename,'w') as f:
            f.write("# v Sigma{sumW sumW2 err} barSigma{sumW sumW2 err} NumEntries\n")
            for v in self.values:
                if self.AbsValues:
                    sig = v[sumW_Sig]/v[nEntries]
                    sig2 = v[sumW2_Sig]/v[nEntries]
                    sigb = v[sumW_bSig]/v[nEntries]
                    sigb2 = v[sumW2_bSig]/v[nEntries]
                else:
                    sig = v[sumW_Sig]
                    sig2 = v[sumW2_Sig]
                    sigb = v[sumW_bSig]
                    sigb2 = v[sumW2_bSig]
                f.write("{VAL} {SIG} {SIGW2} {SIGERR} {BSIG} {BSIGW2} {BSIGERR} {N}\n".format(VAL=v[value],
                                                                                              SIG=sig,
                                                                                              SIGW2=sig2,
                                                                                              SIGERR=v[err_Sig],
                                                                                              BSIG=sigb,
                                                                                              BSIGW2=sigb2,
                                                                                              BSIGERR=v[err_bSig],
                                                                                              N=v[nEntries]))

if __name__=='__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--nll-file', '-nll',default='NLL.dat')
    parser.add_argument('--lo-file', '-lo',default='LO.dat')
    parser.add_argument('--nlo-rs-file', '-nloRS',default='NLO_RS.dat')
    parser.add_argument('--nlo-vi-file', '-nloVI',default='NLO_VI.dat')
    parser.add_argument('--nlo-file', '-nlo', default='NLO_VI.dat')
    parser.add_argument('--observable', '-obs', required=True, action='append')
    parser.add_argument('--rebin', default=1, type=int)
    parser.add_argument('--output-nll', '-NLL', default="NLL.yoda")
    parser.add_argument('--output-lo', '-LO', default="LO.yoda")
    parser.add_argument('--output-nlo', '-NLO', default="NLO.yoda")
    parser.add_argument('--output-match','-o',default="resum-plots")
    parser.add_argument('--channels', '-ch', action='append',default=None)
    parser.add_argument('--channel-fo-add', default=None)
    parser.add_argument('--match', action='store_true', default=False)
    parser.add_argument('--message', '-m', default='warning')
    
    args = parser.parse_args(sys.argv[1:])
    if args.channels is None: 
        args.channels = []
    else:
        args.channels = [ch for chs in args.channels for ch in chs.split()]
    args.observable = [ob for obs in args.observable for ob in obs.split()]
    if args.message.startswith('d'): logging.basicConfig(level=logging.DEBUG)
    if args.message.startswith('i'): logging.basicConfig(level=logging.INFO)
    if args.message.startswith('w'): logging.basicConfig(level=logging.WARNING)
    if args.message.startswith('e'): logging.basicConfig(level=logging.ERROR)
    if args.message.startswith('c'): logging.basicConfig(level=logging.CRITICAL)
    

    
    for obs_mode in args.observable:
        logging.info("\nCombining files for {OBS}".format(OBS=obs))
        obs = obs_mode.split(":")
        if len(obs) > 0: mode = obs[1]
        else: mode = 'ln'
        obs = obs[0]
        logging.info("Looking for {OBS} with mode {M}".format(OBS=obs,M=mode))
        # NLL files
        if os.path.exists(args.nll_file):
            inpath = "{NLL}/{ACC}/{OBS}_Sigma.dat"
            outpath = "/Resum/{OBS}_{ACC}"
            yodas = Sigma.from_file(
                inpath.format(NLL=args.nll_file,
                              ACC="NLL",
                              OBS=obs)).toYoda(outpath.format(OBS=obs,ACC="NLL"),mode=mode)
            yodas += Sigma.from_file(
                inpath.format(NLL=args.nll_file,
                              ACC="LO",
                              OBS=obs)).toYoda(outpath.format(OBS=obs,ACC="LO"),mode=mode)
            yodas += Sigma.from_file(
                inpath.format(NLL=args.nll_file,
                              ACC="NLO",
                              OBS=obs)).toYoda(outpath.format(OBS=obs,ACC="NLO"),mode=mode)
            for ch in args.channels:
                inpath = "{NLL}/{ACC}/Channel_{CH}_{OBS}_Sigma.dat"
                if not os.path.exists(inpath.format(NLL=args.nll_file,ACC="NLL",CH=ch,OBS=obs)):
                    logging.info(("No NLL file for channel "
                                  "{CH}. Ignoring.").format(CH=ch))
                    continue
                outpath = "/Resum/{OBS}_{ACC}_Channel_{CH}"
                
                yodas += Sigma.from_file(
                    inpath.format(NLL=args.nll_file,
                                  ACC="NLL",
                                  CH=ch,
                    OBS=obs)).toYoda(outpath.format(OBS=obs,
                                                    ACC="NLL",
                                                    CH=ch),mode=mode)
                yodas += Sigma.from_file(
                    inpath.format(NLL=args.nll_file,
                                  ACC="LO",
                                  CH=ch,
                                  OBS=obs)).toYoda(outpath.format(OBS=obs,
                                                                  ACC="LO",
                                                                  CH=ch),mode=mode)
                yodas += Sigma.from_file(
                    inpath.format(NLL=args.nll_file,
                                  ACC="NLO",
                                  CH=ch,
                                  OBS=obs)).toYoda(outpath.format(OBS=obs,
                                                                  ACC="NLO",
                                                                  CH=ch),mode=mode)
            yoda.writeYODA(yodas,args.output_nll)
        elif not os.path.exists(args.output_nll):
            args.output_nll = "NO"
        
        # LO files
        if os.path.exists(args.lo_file):
            yodas = []
            inpath = "{ANALYSIS}/{ACC}/{OBS}_Sigma.dat"
            outpath = "/Resum/{OBS}_{ACC}"
            
            yodas = Sigma.from_file(
                inpath.format(ANALYSIS=args.lo_file,
                              ACC="LO",
                        OBS=obs)).toYoda(outpath.format(OBS=obs,ACC="LO"),mode=mode)
            for ch in args.channels:
                if args.channel_fo_add is None:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{OBS}_Sigma.dat"
                else:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{ADD}_{OBS}_Sigma.dat"
                outpath = "/Resum/{OBS}_{ACC}_Channel_{CH}"
        
                yodas += Sigma.from_file(
                    inpath.format(ANALYSIS=args.lo_file,
                                  ACC="LO",
                                  CH=ch,
                                  ADD=args.channel_fo_add,
                                  OBS=obs)).toYoda(outpath.format(OBS=obs,
                                                                  ACC="LO",
                                                                  CH=ch),mode=mode)
            yoda.writeYODA(yodas,args.output_lo)
        elif not os.path.exists(args.output_lo):
            args.output_lo = "NO"
        
        # NLO files
        if os.path.exists(args.nlo_rs_file) and os.path.exists(args.nlo_vi_file):
            yodas = []
            inpath = "{ANALYSIS}/{ACC}/{OBS}_Sigma.dat"
            outpath = "/Resum/{OBS}_{ACC}"
            
            rs = Sigma.from_file(
                inpath.format(ANALYSIS=args.nlo_rs_file,
                              ACC="NLO_RS",
                              OBS=obs))
            vi = Sigma.from_file(
                inpath.format(ANALYSIS=args.nlo_vi_file,
                              ACC="NLO_VI",
                          OBS=obs))
            yodas = (rs+vi).toYoda(outpath.format(OBS=obs,ACC="NLO"),mode=mode)
            for ch in args.channels:
                if args.channel_fo_add is None:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{OBS}_Sigma.dat"
                else:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{ADD}_{OBS}_Sigma.dat"
                outpath = "/Resum/{OBS}_{ACC}_Channel_{CH}"

                rs = Sigma.from_file(
                    inpath.format(ANALYSIS=args.nlo_rs_file,
                                  ACC="NLO_RS",
                                  CH=ch,
                                  ADD=args.channel_fo_add,
                                  OBS=obs))
                vi = Sigma.from_file(
                    inpath.format(ANALYSIS=args.nlo_vi_file,
                                  ACC="NLO_VI",
                                  CH=ch,
                                  ADD=args.channel_fo_add,
                                  OBS=obs))
                yodas += (rs+vi).toYoda(outpath.format(OBS=obs,ACC="NLO",CH=ch),mode=mode)
                
            yoda.writeYODA(yodas,args.output_nlo)
                
        elif os.path.exists(args.nlo_file):
            yodas = []
            inpath = "{ANALYSIS}/{ACC}/{OBS}_Sigma.dat"
            outpath = "/Resum/{OBS}_{ACC}"

            yodas = Sigma.from_file(
                inpath.format(ANALYSIS=args.nlo_file,
                              ACC="LO",
                              OBS=obs)).toYoda(outpath.format(OBS=obs,ACC="LO"),mode=mode)
            for ch in args.channels:
                if args.channel_fo_add is None:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{OBS}_Sigma.dat"
                else:
                    inpath = "{ANALYSIS}/{ACC}/Channel_{CH}_{ADD}_{OBS}_Sigma.dat"
                    outpath = "/Resum/{OBS}_{ACC}_Channel_{CH}"
                    
                    yodas += Sigma.from_file(
                        inpath.format(ANALYSIS=args.lo_file,
                                      ACC="NLO",
                                      CH=ch,
                                      ADD=args.channel_fo_add,
                                      OBS=obs)).toYoda(outpath.format(OBS=obs,
                                                                      ACC="NLO",
                                                                      CH=ch),mode=mode)
            yoda.writeYODA(yodas,args.output_nlo)
        elif not os.path.exists(args.output_nlo):
            args.output_nlo = 'NO'
        
        if args.match:
            if len(args.channels) == 0:
                chstring = []
            elif len(args.channels) == 1:
                chstring = ['-ch',args.channels[0]]
            elif len(args.channels) > 1:
                chstring = ['-ch',"{}".format(" ".join(args.channels))]

            command = (['resum-match',
                       '-lo',args.output_lo,
                       '-nlo',args.output_nlo,
                       '-nll',args.output_nll,
                       '-obs',obs,
                       '--rebin',str(args.rebin),
                       '--message',args.message,
                       '-o', '{DIR}/{OBS}'.format(DIR=args.output_match,
                                                  OBS=obs)]
                       + chstring)
            logging.info(" ".join(command))
            subprocess.call(command)

            fs = {}
            for obs in args.observable:
                for f in glob.glob("{DIR}/{OBS}/*.yoda".format(DIR=args.output_match,
                                                               OBS=obs)):
                    name = f.split("/")[-1]
                    if not name in fs:
                        fs[name] = yoda.readYODA(f,asdict=False)
                    else:
                        fs[name] += yoda.readYODA(f,asdict=False)

            dirName = "{DIR}/Summary".format(DIR=args.output_match)
            if not os.path.exists(dirName): os.makedirs(dirName)
            for key in fs:
                yoda.writeYODA(fs[key],"{DIR}/{NAME}".format(DIR=dirName,
                                                             NAME=key))

            for ch in args.channels:
                fs = {}
                for obs in args.observable:
                    for f in glob.glob("{DIR}/{OBS}-{CH}/*.yoda".format(DIR=args.output_match,
                                                                        OBS=obs,CH=ch)):
                        name = f.split("/")[-1]
                        if not name in fs:
                            fs[name] = yoda.readYODA(f,asdict=False)
                        else:
                            fs[name] += yoda.readYODA(f,asdict=False)

                dirName = "{DIR}/Summary-{CH}".format(DIR=args.output_match,CH=ch)
                if not os.path.exists(dirName): os.makedirs(dirName)
                for key in fs:
                    yoda.writeYODA(fs[key],"{DIR}/{NAME}".format(DIR=dirName,
                                                                 NAME=key))
